# Task Flow å¼€å‘æŒ‡å—

æœ¬æ–‡æ¡£æä¾›è¯¦ç»†çš„ä»£ç æ¨¡æ¿å’Œå®ç°æŒ‡å—ï¼Œç”¨äºåœ¨æ–°å¯¹è¯ä¸­æ‰§è¡Œä»£ç ç”Ÿæˆä»»åŠ¡ã€‚

## 1. é¡¹ç›®åˆå§‹åŒ–

### 1.1 æ ¹ç›®å½•é…ç½®æ–‡ä»¶

#### package.json
```json
{
  "name": "task-flow",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "concurrently \"pnpm --filter server dev\" \"pnpm --filter client dev\"",
    "build": "pnpm --filter client build && pnpm --filter server build",
    "start": "pnpm --filter server start",
    "lint": "pnpm -r lint"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}
```

#### pnpm-workspace.yaml
```yaml
packages:
  - 'packages/*'
```

### 1.2 åç«¯åˆå§‹åŒ–

#### packages/server/package.json
```json
{
  "name": "server",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.10.0",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.0",
    "prisma": "^5.10.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3"
  }
}
```

#### packages/server/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 1.3 å‰ç«¯åˆå§‹åŒ–

#### packages/client/package.json
```json
{
  "name": "client",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx --fix"
  },
  "dependencies": {
    "axios": "^1.6.7",
    "dayjs": "^1.11.10",
    "pinia": "^2.1.7",
    "vue": "^3.4.15",
    "vue-router": "^4.2.5"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "@vitejs/plugin-vue": "^5.0.3",
    "autoprefixer": "^10.4.17",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3",
    "vite": "^5.0.12",
    "vue-tsc": "^1.8.27"
  }
}
```

#### packages/client/vite.config.ts
```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true
      }
    }
  }
})
```

#### packages/client/tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#4f46e5',
          hover: '#4338ca'
        },
        status: {
          pending: '#9ca3af',
          design: '#3b82f6',
          develop: '#10b981',
          test: '#f59e0b',
          delivery: '#f97316',
          done: '#22c55e'
        }
      }
    },
  },
  plugins: [],
}
```

## 2. åç«¯ä»£ç æ¨¡æ¿

### 2.1 å…¥å£æ–‡ä»¶

```typescript
// packages/server/src/index.ts
import express from 'express'
import cors from 'cors'
import { PrismaClient } from '@prisma/client'
import workItemRoutes from './routes/work-item'
import commentRoutes from './routes/comment'
import activityLogRoutes from './routes/activity-log'
import recycleBinRoutes from './routes/recycle-bin'
import statsRoutes from './routes/stats'
import { errorHandler } from './middleware/error-handler'

const app = express()
const prisma = new PrismaClient()
const PORT = process.env.PORT || 3001

app.use(cors())
app.use(express.json())

// å°† prisma å®ä¾‹é™„åŠ åˆ°è¯·æ±‚å¯¹è±¡
app.use((req, res, next) => {
  req.prisma = prisma
  next()
})

// è·¯ç”±
app.use('/api/v1/work-items', workItemRoutes)
app.use('/api/v1/comments', commentRoutes)
app.use('/api/v1/activity-logs', activityLogRoutes)
app.use('/api/v1/recycle-bin', recycleBinRoutes)
app.use('/api/v1/stats', statsRoutes)

// é”™è¯¯å¤„ç†
app.use(errorHandler)

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`)
})

// ä¼˜é›…å…³é—­
process.on('SIGINT', async () => {
  await prisma.$disconnect()
  process.exit(0)
})
```

### 2.2 ç±»å‹æ‰©å±•

```typescript
// packages/server/src/types/index.ts
import { PrismaClient } from '@prisma/client'

declare global {
  namespace Express {
    interface Request {
      prisma: PrismaClient
    }
  }
}

export interface ApiResponse<T = any> {
  code: number
  data?: T
  message: string
}

export const StatusEnum = {
  PENDING: 'pending',
  DESIGN: 'design',
  DEVELOP: 'develop',
  TEST: 'test',
  DELIVERY: 'delivery',
  DONE: 'done'
} as const

export type Status = typeof StatusEnum[keyof typeof StatusEnum]

export const ActivityLogType = {
  CREATE: 'create',
  UPDATE: 'update',
  STATUS: 'status',
  COMMENT: 'comment',
  DELETE: 'delete',
  RESTORE: 'restore'
} as const

export type ActivityType = typeof ActivityLogType[keyof typeof ActivityLogType]
```

### 2.3 å“åº”å·¥å…·

```typescript
// packages/server/src/utils/response.ts
import { Response } from 'express'
import { ApiResponse } from '../types'

export function success<T>(res: Response, data: T, message = 'success') {
  const response: ApiResponse<T> = {
    code: 0,
    data,
    message
  }
  res.json(response)
}

export function error(res: Response, message: string, code = 1, status = 400) {
  const response: ApiResponse = {
    code,
    message
  }
  res.status(status).json(response)
}
```

### 2.4 é”™è¯¯å¤„ç†ä¸­é—´ä»¶

```typescript
// packages/server/src/middleware/error-handler.ts
import { Request, Response, NextFunction } from 'express'
import { ZodError } from 'zod'
import { error } from '../utils/response'

export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.error(err)

  if (err instanceof ZodError) {
    return error(res, 'å‚æ•°æ ¡éªŒå¤±è´¥', 400, 400)
  }

  error(res, err.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯', 500, 500)
}
```

### 2.5 å·¥ä½œé¡¹è·¯ç”±ç¤ºä¾‹

```typescript
// packages/server/src/routes/work-item.ts
import { Router } from 'express'
import { z } from 'zod'
import { success, error } from '../utils/response'
import * as workItemService from '../services/work-item'

const router = Router()

// è·å–å·¥ä½œé¡¹åˆ—è¡¨
router.get('/', async (req, res, next) => {
  try {
    const { status, search, sort = 'updatedAt', order = 'desc' } = req.query
    
    const items = await workItemService.getWorkItems(req.prisma, {
      status: status as string,
      search: search as string,
      sort: sort as string,
      order: order as 'asc' | 'desc'
    })
    
    success(res, items)
  } catch (err) {
    next(err)
  }
})

// è·å–å·¥ä½œé¡¹è¯¦æƒ…
router.get('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id)
    const item = await workItemService.getWorkItemById(req.prisma, id)
    
    if (!item) {
      return error(res, 'å·¥ä½œé¡¹ä¸å­˜åœ¨', 404, 404)
    }
    
    success(res, item)
  } catch (err) {
    next(err)
  }
})

// åˆ›å»ºå·¥ä½œé¡¹
const createSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().max(5000).optional(),
  status: z.enum(['pending', 'design', 'develop', 'test', 'delivery', 'done']).default('pending'),
  startTime: z.string().datetime().optional(),
  endTime: z.string().datetime().optional(),
  parentId: z.number().optional()
})

router.post('/', async (req, res, next) => {
  try {
    const data = createSchema.parse(req.body)
    const item = await workItemService.createWorkItem(req.prisma, data)
    success(res, item, 'åˆ›å»ºæˆåŠŸ')
  } catch (err) {
    next(err)
  }
})

// æ›´æ–°å·¥ä½œé¡¹
const updateSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  content: z.string().max(5000).optional(),
  status: z.enum(['pending', 'design', 'develop', 'test', 'delivery', 'done']).optional(),
  startTime: z.string().datetime().optional(),
  endTime: z.string().datetime().optional()
})

router.put('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id)
    const data = updateSchema.parse(req.body)
    const item = await workItemService.updateWorkItem(req.prisma, id, data)
    success(res, item, 'æ›´æ–°æˆåŠŸ')
  } catch (err) {
    next(err)
  }
})

// åˆ é™¤å·¥ä½œé¡¹ï¼ˆè½¯åˆ é™¤ï¼‰
router.delete('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id)
    await workItemService.softDeleteWorkItem(req.prisma, id)
    success(res, null, 'å·²ç§»è‡³å›æ”¶ç«™')
  } catch (err) {
    next(err)
  }
})

// æ¢å¤å·¥ä½œé¡¹
router.post('/:id/restore', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id)
    const item = await workItemService.restoreWorkItem(req.prisma, id)
    success(res, item, 'æ¢å¤æˆåŠŸ')
  } catch (err) {
    next(err)
  }
})

// å½»åº•åˆ é™¤
router.delete('/:id/permanent', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id)
    await workItemService.permanentDeleteWorkItem(req.prisma, id)
    success(res, null, 'å·²å½»åº•åˆ é™¤')
  } catch (err) {
    next(err)
  }
})

export default router
```

### 2.6 å·¥ä½œé¡¹æœåŠ¡ç¤ºä¾‹

```typescript
// packages/server/src/services/work-item.ts
import { PrismaClient, Prisma } from '@prisma/client'

interface GetWorkItemsOptions {
  status?: string
  search?: string
  sort?: string
  order?: 'asc' | 'desc'
  includeDeleted?: boolean
}

export async function getWorkItems(prisma: PrismaClient, options: GetWorkItemsOptions) {
  const { status, search, sort = 'updatedAt', order = 'desc', includeDeleted = false } = options

  const where: Prisma.WorkItemWhereInput = {
    parentId: null, // åªè·å–é¡¶çº§å·¥ä½œé¡¹
    deletedAt: includeDeleted ? undefined : null
  }

  if (status) {
    where.status = status
  }

  if (search) {
    where.OR = [
      { title: { contains: search } },
      { content: { contains: search } }
    ]
  }

  const items = await prisma.workItem.findMany({
    where,
    orderBy: { [sort]: order },
    include: {
      _count: {
        select: {
          children: true,
          comments: true
        }
      }
    }
  })

  // è®¡ç®—å­é¡¹ç»Ÿè®¡
  return Promise.all(items.map(async (item) => {
    const childStats = await getChildStats(prisma, item.id)
    return { ...item, childStats }
  }))
}

export async function getWorkItemById(prisma: PrismaClient, id: number) {
  return prisma.workItem.findUnique({
    where: { id },
    include: {
      children: {
        include: {
          children: {
            include: {
              children: true
            }
          }
        }
      },
      comments: {
        orderBy: { createdAt: 'desc' }
      }
    }
  })
}

export async function createWorkItem(prisma: PrismaClient, data: {
  title: string
  content?: string
  status?: string
  startTime?: string
  endTime?: string
  parentId?: number
}) {
  const item = await prisma.workItem.create({
    data: {
      title: data.title,
      content: data.content,
      status: data.status || 'pending',
      startTime: data.startTime ? new Date(data.startTime) : undefined,
      endTime: data.endTime ? new Date(data.endTime) : undefined,
      parentId: data.parentId
    }
  })

  // è®°å½•æ´»åŠ¨æ—¥å¿—
  await prisma.activityLog.create({
    data: {
      type: 'create',
      description: data.parentId ? 'åˆ›å»ºäº†å­å·¥ä½œé¡¹' : 'åˆ›å»ºäº†æ–°å·¥ä½œé¡¹',
      workItemId: data.parentId || item.id
    }
  })

  return item
}

export async function updateWorkItem(prisma: PrismaClient, id: number, data: {
  title?: string
  content?: string
  status?: string
  startTime?: string
  endTime?: string
}) {
  const oldItem = await prisma.workItem.findUnique({ where: { id } })
  if (!oldItem) throw new Error('å·¥ä½œé¡¹ä¸å­˜åœ¨')

  const item = await prisma.workItem.update({
    where: { id },
    data: {
      title: data.title,
      content: data.content,
      status: data.status,
      startTime: data.startTime ? new Date(data.startTime) : undefined,
      endTime: data.endTime ? new Date(data.endTime) : undefined
    }
  })

  // è®°å½•çŠ¶æ€å˜æ›´
  if (data.status && data.status !== oldItem.status) {
    await prisma.activityLog.create({
      data: {
        type: 'status',
        description: `çŠ¶æ€ä»"${getStatusLabel(oldItem.status)}"å˜æ›´ä¸º"${getStatusLabel(data.status)}"`,
        oldValue: oldItem.status,
        newValue: data.status,
        workItemId: oldItem.parentId || id
      }
    })
  } else {
    await prisma.activityLog.create({
      data: {
        type: 'update',
        description: 'æ›´æ–°äº†å·¥ä½œé¡¹å†…å®¹',
        workItemId: oldItem.parentId || id
      }
    })
  }

  return item
}

export async function softDeleteWorkItem(prisma: PrismaClient, id: number) {
  const item = await prisma.workItem.update({
    where: { id },
    data: { deletedAt: new Date() }
  })

  await prisma.activityLog.create({
    data: {
      type: 'delete',
      description: 'å·¥ä½œé¡¹è¢«åˆ é™¤åˆ°å›æ”¶ç«™',
      workItemId: id
    }
  })

  return item
}

export async function restoreWorkItem(prisma: PrismaClient, id: number) {
  const item = await prisma.workItem.update({
    where: { id },
    data: { deletedAt: null }
  })

  await prisma.activityLog.create({
    data: {
      type: 'restore',
      description: 'å·¥ä½œé¡¹ä»å›æ”¶ç«™æ¢å¤',
      workItemId: id
    }
  })

  return item
}

export async function permanentDeleteWorkItem(prisma: PrismaClient, id: number) {
  return prisma.workItem.delete({ where: { id } })
}

async function getChildStats(prisma: PrismaClient, parentId: number) {
  const children = await prisma.workItem.findMany({
    where: { parentId }
  })

  if (children.length === 0) return null

  const done = children.filter(c => c.status === 'done').length
  return {
    total: children.length,
    done,
    percentage: Math.round((done / children.length) * 100)
  }
}

function getStatusLabel(status: string): string {
  const labels: Record<string, string> = {
    pending: 'å¾…å¤„ç†',
    design: 'è®¾è®¡ä¸­',
    develop: 'å¼€å‘ä¸­',
    test: 'æµ‹è¯•ä¸­',
    delivery: 'äº¤ä»˜ä¸­',
    done: 'å·²å®Œæˆ'
  }
  return labels[status] || status
}
```

## 3. å‰ç«¯ä»£ç æ¨¡æ¿

### 3.1 å…¥å£æ–‡ä»¶

```typescript
// packages/client/src/main.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import router from './router'
import App from './App.vue'
import './assets/css/main.css'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')
```

### 3.2 è·¯ç”±é…ç½®

```typescript
// packages/client/src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      name: 'WorkItemList',
      component: () => import('@/views/WorkItemList.vue')
    },
    {
      path: '/work-item/:id',
      name: 'WorkItemDetail',
      component: () => import('@/views/WorkItemDetail.vue')
    },
    {
      path: '/daily-log',
      name: 'DailyLog',
      component: () => import('@/views/DailyLog.vue')
    },
    {
      path: '/recycle-bin',
      name: 'RecycleBin',
      component: () => import('@/views/RecycleBin.vue')
    }
  ]
})

export default router
```

### 3.3 API å°è£…

```typescript
// packages/client/src/api/index.ts
import axios from 'axios'

const api = axios.create({
  baseURL: '/api/v1',
  timeout: 10000
})

api.interceptors.response.use(
  response => {
    const { data } = response
    if (data.code === 0) {
      return data.data
    }
    return Promise.reject(new Error(data.message))
  },
  error => {
    return Promise.reject(error)
  }
)

export default api
```

```typescript
// packages/client/src/api/work-item.ts
import api from './index'
import type { WorkItem, CreateWorkItemDto, UpdateWorkItemDto } from '@/types'

export function getWorkItems(params?: {
  status?: string
  search?: string
  sort?: string
  order?: string
}) {
  return api.get<WorkItem[]>('/work-items', { params })
}

export function getWorkItem(id: number) {
  return api.get<WorkItem>(`/work-items/${id}`)
}

export function createWorkItem(data: CreateWorkItemDto) {
  return api.post<WorkItem>('/work-items', data)
}

export function updateWorkItem(id: number, data: UpdateWorkItemDto) {
  return api.put<WorkItem>(`/work-items/${id}`, data)
}

export function deleteWorkItem(id: number) {
  return api.delete(`/work-items/${id}`)
}

export function restoreWorkItem(id: number) {
  return api.post(`/work-items/${id}/restore`)
}

export function permanentDeleteWorkItem(id: number) {
  return api.delete(`/work-items/${id}/permanent`)
}
```

### 3.4 ç±»å‹å®šä¹‰

```typescript
// packages/client/src/types/index.ts
export type Status = 'pending' | 'design' | 'develop' | 'test' | 'delivery' | 'done'

export interface WorkItem {
  id: number
  title: string
  content: string | null
  status: Status
  startTime: string | null
  endTime: string | null
  createdAt: string
  updatedAt: string
  deletedAt: string | null
  parentId: number | null
  children?: WorkItem[]
  comments?: Comment[]
  _count?: {
    children: number
    comments: number
  }
  childStats?: {
    total: number
    done: number
    percentage: number
  } | null
}

export interface Comment {
  id: number
  content: string
  createdAt: string
  updatedAt: string
  workItemId: number
}

export interface ActivityLog {
  id: number
  type: 'create' | 'update' | 'status' | 'comment' | 'delete' | 'restore'
  description: string
  oldValue: string | null
  newValue: string | null
  createdAt: string
  workItemId: number
  workItem?: {
    id: number
    title: string
  }
}

export interface CreateWorkItemDto {
  title: string
  content?: string
  status?: Status
  startTime?: string
  endTime?: string
  parentId?: number
}

export interface UpdateWorkItemDto {
  title?: string
  content?: string
  status?: Status
  startTime?: string
  endTime?: string
}

export interface Stats {
  total: number
  pending: number
  inProgress: number
  done: number
  recycled: number
}

export const STATUS_CONFIG: Record<Status, { label: string; color: string; bgColor: string }> = {
  pending: { label: 'å¾…å¤„ç†', color: '#6b7280', bgColor: 'rgba(156, 163, 175, 0.15)' },
  design: { label: 'è®¾è®¡ä¸­', color: '#2563eb', bgColor: 'rgba(59, 130, 246, 0.15)' },
  develop: { label: 'å¼€å‘ä¸­', color: '#059669', bgColor: 'rgba(16, 185, 129, 0.15)' },
  test: { label: 'æµ‹è¯•ä¸­', color: '#d97706', bgColor: 'rgba(245, 158, 11, 0.15)' },
  delivery: { label: 'äº¤ä»˜ä¸­', color: '#ea580c', bgColor: 'rgba(249, 115, 22, 0.15)' },
  done: { label: 'å·²å®Œæˆ', color: '#16a34a', bgColor: 'rgba(34, 197, 94, 0.15)' }
}
```

### 3.5 çŠ¶æ€ç®¡ç†

```typescript
// packages/client/src/stores/work-item.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import * as workItemApi from '@/api/work-item'
import * as statsApi from '@/api/stats'
import type { WorkItem, Stats } from '@/types'

export const useWorkItemStore = defineStore('workItem', () => {
  const items = ref<WorkItem[]>([])
  const currentItem = ref<WorkItem | null>(null)
  const loading = ref(false)
  const stats = ref<Stats>({
    total: 0,
    pending: 0,
    inProgress: 0,
    done: 0,
    recycled: 0
  })

  async function fetchWorkItems(params?: {
    status?: string
    search?: string
    sort?: string
    order?: string
  }) {
    loading.value = true
    try {
      items.value = await workItemApi.getWorkItems(params)
    } finally {
      loading.value = false
    }
  }

  async function fetchWorkItem(id: number) {
    loading.value = true
    try {
      currentItem.value = await workItemApi.getWorkItem(id)
    } finally {
      loading.value = false
    }
  }

  async function createWorkItem(data: any) {
    const item = await workItemApi.createWorkItem(data)
    await fetchWorkItems()
    await fetchStats()
    return item
  }

  async function updateWorkItem(id: number, data: any) {
    const item = await workItemApi.updateWorkItem(id, data)
    if (currentItem.value?.id === id) {
      await fetchWorkItem(id)
    }
    await fetchWorkItems()
    return item
  }

  async function deleteWorkItem(id: number) {
    await workItemApi.deleteWorkItem(id)
    await fetchWorkItems()
    await fetchStats()
  }

  async function restoreWorkItem(id: number) {
    await workItemApi.restoreWorkItem(id)
    await fetchStats()
  }

  async function fetchStats() {
    stats.value = await statsApi.getStats()
  }

  return {
    items,
    currentItem,
    loading,
    stats,
    fetchWorkItems,
    fetchWorkItem,
    createWorkItem,
    updateWorkItem,
    deleteWorkItem,
    restoreWorkItem,
    fetchStats
  }
})
```

### 3.6 ç»„åˆå¼å‡½æ•°

```typescript
// packages/client/src/composables/useToast.ts
import { ref } from 'vue'

interface ToastOptions {
  message: string
  type?: 'success' | 'error' | 'info'
  duration?: number
}

const toasts = ref<Array<ToastOptions & { id: number }>>([])
let id = 0

export function useToast() {
  function show(options: ToastOptions) {
    const toastId = ++id
    toasts.value.push({
      ...options,
      id: toastId,
      type: options.type || 'success',
      duration: options.duration || 3000
    })

    setTimeout(() => {
      const index = toasts.value.findIndex(t => t.id === toastId)
      if (index > -1) {
        toasts.value.splice(index, 1)
      }
    }, options.duration || 3000)
  }

  function success(message: string) {
    show({ message, type: 'success' })
  }

  function error(message: string) {
    show({ message, type: 'error' })
  }

  function info(message: string) {
    show({ message, type: 'info' })
  }

  return {
    toasts,
    show,
    success,
    error,
    info
  }
}
```

```typescript
// packages/client/src/composables/useConfirm.ts
import { ref } from 'vue'

interface ConfirmOptions {
  title?: string
  message: string
  confirmText?: string
  cancelText?: string
  type?: 'danger' | 'warning' | 'info'
}

const visible = ref(false)
const options = ref<ConfirmOptions>({
  message: ''
})
let resolvePromise: ((value: boolean) => void) | null = null

export function useConfirm() {
  function confirm(opts: ConfirmOptions): Promise<boolean> {
    options.value = {
      title: opts.title || 'ç¡®è®¤',
      message: opts.message,
      confirmText: opts.confirmText || 'ç¡®å®š',
      cancelText: opts.cancelText || 'å–æ¶ˆ',
      type: opts.type || 'warning'
    }
    visible.value = true

    return new Promise((resolve) => {
      resolvePromise = resolve
    })
  }

  function handleConfirm() {
    visible.value = false
    resolvePromise?.(true)
  }

  function handleCancel() {
    visible.value = false
    resolvePromise?.(false)
  }

  return {
    visible,
    options,
    confirm,
    handleConfirm,
    handleCancel
  }
}
```

### 3.7 å¸ƒå±€ç»„ä»¶

```vue
<!-- packages/client/src/components/layout/AppLayout.vue -->
<template>
  <div class="flex min-h-screen bg-slate-50">
    <AppSidebar />
    <div class="flex-1 ml-60">
      <AppHeader :title="title" />
      <main class="p-6">
        <slot />
      </main>
    </div>
  </div>
</template>

<script setup lang="ts">
import AppSidebar from './AppSidebar.vue'
import AppHeader from './AppHeader.vue'

defineProps<{
  title: string
}>()
</script>
```

```vue
<!-- packages/client/src/components/layout/AppSidebar.vue -->
<template>
  <aside class="w-60 bg-slate-800 text-white fixed top-0 left-0 bottom-0 flex flex-col">
    <div class="p-5 border-b border-white/10">
      <div class="flex items-center gap-2.5 text-xl font-semibold">
        <div class="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">
          <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 11l3 3L22 4"></path>
            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
          </svg>
        </div>
        <span>Task Flow</span>
      </div>
    </div>
    
    <nav class="flex-1 py-4">
      <RouterLink
        v-for="item in navItems"
        :key="item.path"
        :to="item.path"
        class="nav-item"
        :class="{ active: $route.path === item.path }"
      >
        <component :is="item.icon" class="w-5 h-5" />
        <span>{{ item.label }}</span>
      </RouterLink>
    </nav>
  </aside>
</template>

<script setup lang="ts">
import { h } from 'vue'

const navItems = [
  { path: '/', label: 'å·¥ä½œé¡¹ç®¡ç†', icon: () => h('span', 'ğŸ“‹') },
  { path: '/daily-log', label: 'æ—¥å¿—æŸ¥çœ‹', icon: () => h('span', 'ğŸ“…') },
  { path: '/recycle-bin', label: 'å›æ”¶ç«™', icon: () => h('span', 'ğŸ—‘ï¸') }
]
</script>

<style scoped>
.nav-item {
  @apply flex items-center gap-3 px-5 py-3 text-white/70 cursor-pointer transition-all border-l-[3px] border-transparent hover:bg-white/5 hover:text-white;
}
.nav-item.active {
  @apply bg-white/10 text-white border-l-primary;
}
</style>
```

### 3.8 é€šç”¨ç»„ä»¶

```vue
<!-- packages/client/src/components/common/StatusTag.vue -->
<template>
  <span
    class="inline-flex items-center gap-1 px-2.5 py-1 text-xs font-medium rounded-full"
    :style="{ backgroundColor: config.bgColor, color: config.color }"
  >
    <span class="w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: config.color }"></span>
    {{ config.label }}
  </span>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { STATUS_CONFIG, type Status } from '@/types'

const props = defineProps<{
  status: Status
}>()

const config = computed(() => STATUS_CONFIG[props.status])
</script>
```

```vue
<!-- packages/client/src/components/common/BaseModal.vue -->
<template>
  <Teleport to="body">
    <Transition name="modal">
      <div v-if="visible" class="modal-overlay" @click.self="$emit('close')">
        <div class="modal" :style="{ maxWidth: width }">
          <div class="modal-header">
            <h3 class="modal-title">{{ title }}</h3>
            <button class="modal-close" @click="$emit('close')">&times;</button>
          </div>
          <div class="modal-body">
            <slot />
          </div>
          <div v-if="$slots.footer" class="modal-footer">
            <slot name="footer" />
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup lang="ts">
defineProps<{
  visible: boolean
  title: string
  width?: string
}>()

defineEmits<{
  close: []
}>()
</script>

<style scoped>
.modal-overlay {
  @apply fixed inset-0 bg-black/50 flex items-center justify-center z-50;
}
.modal {
  @apply bg-white rounded-xl shadow-xl w-full max-h-[90vh] overflow-y-auto;
}
.modal-header {
  @apply flex items-center justify-between px-6 py-5 border-b border-slate-200;
}
.modal-title {
  @apply text-lg font-semibold;
}
.modal-close {
  @apply w-8 h-8 flex items-center justify-center rounded-lg text-slate-400 hover:bg-slate-100 text-xl;
}
.modal-body {
  @apply p-6;
}
.modal-footer {
  @apply flex justify-end gap-3 px-6 py-4 border-t border-slate-200;
}

.modal-enter-active,
.modal-leave-active {
  transition: opacity 0.3s ease;
}
.modal-enter-from,
.modal-leave-to {
  opacity: 0;
}
</style>
```

## 4. Docker éƒ¨ç½²

### 4.1 Dockerfile

```dockerfile
# docker/Dockerfile
FROM node:20-slim AS base
RUN npm install -g pnpm

# æ„å»ºé˜¶æ®µ
FROM base AS builder
WORKDIR /app
COPY pnpm-workspace.yaml package.json pnpm-lock.yaml ./
COPY packages/client/package.json ./packages/client/
COPY packages/server/package.json ./packages/server/
RUN pnpm install --frozen-lockfile

COPY . .
RUN pnpm --filter client build
RUN pnpm --filter server build

# ç”Ÿäº§é˜¶æ®µ
FROM base AS runner
WORKDIR /app

COPY --from=builder /app/packages/server/dist ./dist
COPY --from=builder /app/packages/server/prisma ./prisma
COPY --from=builder /app/packages/server/package.json ./
COPY --from=builder /app/packages/client/dist ./public

RUN pnpm install --prod

ENV NODE_ENV=production
ENV DATABASE_URL="file:./data/taskflow.db"
ENV PORT=3000

RUN npx prisma generate

EXPOSE 3000
CMD ["node", "dist/index.js"]
```

### 4.2 docker-compose.yml

```yaml
# docker-compose.yml
version: '3.8'

services:
  taskflow:
    build:
      context: .
      dockerfile: docker/Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ./data:/app/data
    environment:
      - NODE_ENV=production
      - DATABASE_URL=file:./data/taskflow.db
    restart: unless-stopped
```

## 5. å¼€å‘ä»»åŠ¡æ¸…å•

ä»¥ä¸‹æ˜¯æŒ‰é¡ºåºæ‰§è¡Œçš„å¼€å‘ä»»åŠ¡ï¼š

### é˜¶æ®µä¸€ï¼šé¡¹ç›®åˆå§‹åŒ–
- [ ] 1.1 åˆ›å»ºé¡¹ç›®æ ¹ç›®å½•ç»“æ„
- [ ] 1.2 åˆå§‹åŒ– pnpm workspace
- [ ] 1.3 åˆå§‹åŒ–åç«¯é¡¹ç›® (Express + TypeScript)
- [ ] 1.4 åˆå§‹åŒ–å‰ç«¯é¡¹ç›® (Vue 3 + Vite + TypeScript)
- [ ] 1.5 é…ç½® Prisma å’Œæ•°æ®åº“ Schema
- [ ] 1.6 é…ç½® TailwindCSS
- [ ] 1.7 æ‰§è¡Œæ•°æ®åº“è¿ç§»

### é˜¶æ®µäºŒï¼šåç«¯ API å¼€å‘
- [ ] 2.1 å®ç°åç«¯å…¥å£å’Œä¸­é—´ä»¶
- [ ] 2.2 å®ç°å·¥ä½œé¡¹ CRUD API
- [ ] 2.3 å®ç°è¯„è®º API
- [ ] 2.4 å®ç°æ´»åŠ¨æ—¥å¿— API
- [ ] 2.5 å®ç°å›æ”¶ç«™ API
- [ ] 2.6 å®ç°ç»Ÿè®¡ API
- [ ] 2.7 æ·»åŠ è¯·æ±‚å‚æ•°æ ¡éªŒ

### é˜¶æ®µä¸‰ï¼šå‰ç«¯åŸºç¡€å¼€å‘
- [ ] 3.1 å®ç°å¸ƒå±€ç»„ä»¶
- [ ] 3.2 å®ç°é€šç”¨ç»„ä»¶
- [ ] 3.3 å®ç° API å°è£…å±‚
- [ ] 3.4 å®ç°ç±»å‹å®šä¹‰
- [ ] 3.5 å®ç°çŠ¶æ€ç®¡ç†
- [ ] 3.6 å®ç°ç»„åˆå¼å‡½æ•°

### é˜¶æ®µå››ï¼šå‰ç«¯é¡µé¢å¼€å‘
- [ ] 4.1 å®ç°å·¥ä½œé¡¹åˆ—è¡¨é¡µ
- [ ] 4.2 å®ç°å·¥ä½œé¡¹è¯¦æƒ…é¡µ
- [ ] 4.3 å®ç°æ—¥å¿—æŸ¥çœ‹é¡µ
- [ ] 4.4 å®ç°å›æ”¶ç«™é¡µé¢

### é˜¶æ®µäº”ï¼šéƒ¨ç½²é…ç½®
- [ ] 5.1 é…ç½®ç”Ÿäº§ç¯å¢ƒæ„å»º
- [ ] 5.2 é…ç½® Docker
- [ ] 5.3 æµ‹è¯•éƒ¨ç½²
